# -*- coding: utf-8 -*-
"""
/***************************************************************************
 LYDialog
                                 A QGIS plugin
 LY
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-10-18
        git sha              : $Format:%H$
        copyright            : (C) 2020 by LY
        email                : LY
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic, QtWidgets, QtGui
from PyQt5.QtCore import pyqtSlot, QVariant

from qgis.core import QgsProject, QgsRasterLayer, QgsPalettedRasterRenderer, QgsField, QgsCategorizedSymbolRenderer, QgsRendererCategory, QgsFillSymbol, QgsVectorLayer
from qgis import processing

from osgeo import gdal as osgdal
from osgeo import gdal, osr

import cv2
import numpy as np
from matplotlib import pyplot as plt
# from sklearn.cluster import AgglomerativeClustering

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
# FORM_CLASS, _ = uic.loadUiType(os.path.join(
#     os.path.dirname(__file__), 'LY_dialog_base.ui'))

# 使用导入生成PY文件的方法提供智能提示
from .LY_dialog_base import Ui_LYDialogBase as FORM_CLASS


class LYDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(LYDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        print('LY Plugin setup')

    def showEvent(self, event: QtGui.QShowEvent):
        '''
        窗口显示事件
        '''

        # 将所有图层添加到图层选择框
        self.rasterLayerComboBox.addItems(
            [layer.name() for layer in QgsProject.instance().mapLayers(
            ).values() if isinstance(layer, QgsRasterLayer)]
        )
        self.vectorLayerComboBox.addItems(
            [layer.name() for layer in QgsProject.instance().mapLayers(
            ).values() if isinstance(layer, QgsVectorLayer)]
        )

    @pyqtSlot()
    def on_cannyPushButton_clicked(self):

        raster_layer_name = self.rasterLayerComboBox.currentText()
        raster_layer = QgsProject.instance(
        ).mapLayersByName(raster_layer_name)[0]
        provider = raster_layer.dataProvider()

        extent = provider.extent()
        rows = raster_layer.height()
        cols = raster_layer.width()

        # 读取栅格值

        block = provider.block(1, extent, cols, rows)
        img = np.zeros([rows, cols, 3], np.uint8)

        band_num = 3
        for band_index in range(band_num):
            block = provider.block(band_index + 1, extent, cols, rows)
            # for row_index in range(rows):
            #     for col_index in range(cols):
            #         img[row_index][col_index][band_index] = block.value(
            #             row_index, col_index)
            img[:, :, band_index] = np.array(
                block.data()).reshape([rows, cols])

        print(img)
        print(img.shape)

        edges = cv2.Canny(img, 200, 400, 15)
        plt.subplot(121)
        plt.imshow(img)
        plt.title('Original Image')
        plt.xticks([])
        plt.yticks([])
        plt.subplot(122)
        plt.imshow(edges, cmap='gray')
        plt.title('Edge Image')
        plt.xticks([])
        plt.yticks([])
        plt.show()
        cv2.imwrite(r'edge_result.jpg', edges)

        # 写入Tiff

        driver = gdal.GetDriverByName('GTiff')

        # 创建图像
        print(f'cols {cols}, rows {rows}')
        ds = driver.Create('edge_result.tif', xsize=cols,
                           ysize=rows, bands=1, eType=gdal.GDT_Byte)
        # 设置参考坐标系
        crs_wkt = raster_layer.crs().toWkt()
        ds.SetProjection(crs_wkt)
        print(crs_wkt)

        # srs = osr.SpatialReference()
        # srs.SetUTM(12, 1)
        # srs.SetWellKnownGeogCS('WGS84')
        # ds.SetProjection(srs.ExportToWkt())

        # 设置Tiff的图像转换参数
        transformParam = [extent.xMinimum(), (extent.width() / cols),
                          0, extent.yMaximum(), 0, - (extent.height() / rows)]
        ds.SetGeoTransform(transformParam)
        print(transformParam)
        # 写入数据
        ds.GetRasterBand(1).WriteArray(edges[:, :])
        # 关闭文件
        ds = None

        # 添加至图层并设置样式

        rlayer = QgsRasterLayer('edge_result.tif', "result tif layer")
        QgsProject.instance().addMapLayer(rlayer)

        palette_raster_render = QgsPalettedRasterRenderer(rlayer.dataProvider(), 1,
                                                          [QgsPalettedRasterRenderer.Class(
                                                              0, QtGui.QColor(0, 0, 0, 0)),
                                                           QgsPalettedRasterRenderer.Class(
                                                              255, QtGui.QColor(255, 0, 0, 255))
                                                           ]
                                                          )
        rlayer.setRenderer(palette_raster_render)

    @pyqtSlot()
    def on_classifyPushButton_clicked(self):

        input_raster_layer_name = self.rasterLayerComboBox.currentText()
        input_vector_layer_name = self.vectorLayerComboBox.currentText()

        # 调用QGIS区域统计工具

        processing.run('qgis:zonalstatistics', {
            'INPUT_RASTER': input_raster_layer_name,
            'RASTER_BAND': 1,
            'INPUT_VECTOR': input_vector_layer_name,
            'COLUMN_PREFIX': 'Band1_',
            'STATS': 2
        })
        processing.run('qgis:zonalstatistics', {
            'INPUT_RASTER': input_raster_layer_name,
            'RASTER_BAND': 2,
            'INPUT_VECTOR': input_vector_layer_name,
            'COLUMN_PREFIX': 'Band2_',
            'STATS': 2
        })
        processing.run('qgis:zonalstatistics', {
            'INPUT_RASTER': input_raster_layer_name,
            'RASTER_BAND': 3,
            'INPUT_VECTOR': input_vector_layer_name,
            'COLUMN_PREFIX': 'Band3_',
            'STATS': 2
        })
        # QgsProject.instance().addMapLayer(vector_layer)

        # 获取计算结果

        input_vector_layer = QgsProject.instance(
        ).mapLayersByName(input_vector_layer_name)[0]

        features = input_vector_layer.getFeatures()
        feature_id_list = []
        feature_band_list = []
        for feature in features:
            feature_id_list.append(feature.id())
            feature_band_list.append([feature['Band1_mean'],
                                      feature['Band2_mean'], feature['Band3_mean']])

        # 聚类

        cluster_num = self.spinBox.value()
        cluster_result = cluster(np.array(feature_band_list))

        # 添加聚类结果到字段，字段存在则删除。只要涉及字段操作，每次操作都要更新字段

        field_name_list = [
            field.name() for field in input_vector_layer.fields()]
        if 'cluster_id' in field_name_list:
            input_vector_layer.dataProvider().deleteAttributes(
                [field_name_list.index('cluster_id')])
            input_vector_layer.updateFields()

        input_vector_layer.dataProvider().addAttributes(
            [QgsField("cluster_id", QVariant.Int)])
        input_vector_layer.updateFields()
        field_name_list = [
            field.name() for field in input_vector_layer.fields()]
        print(field_name_list)
        cluster_id_field_index = field_name_list.index('cluster_id')

        for index, fid in enumerate(feature_id_list):
            attrs = {cluster_id_field_index: int(cluster_result[index])}
            change_result = input_vector_layer.dataProvider(
            ).changeAttributeValues({fid: attrs})
            print(fid)
            print(attrs)
            print(change_result)
        input_vector_layer.updateFields()

        # 符号化

        categorized_renderer = QgsCategorizedSymbolRenderer()
        categorized_renderer.setClassAttribute('cluster_id')

        for cluster_id in range(cluster_num):
            fill_symbol = QgsFillSymbol.createSimple({})
            fill_symbol.setColor(QtGui.QColor(
                *np.random.randint(0, 256, 3), 200))
            categorized_renderer.addCategory(QgsRendererCategory(cluster_id,
                                                                 fill_symbol,
                                                                 f'cluster {cluster_id}'
                                                                 ))
        input_vector_layer.setRenderer(categorized_renderer)


def cluster(X: np.array, cluster_num=5):
    count = X.shape[0]
    return np.random.randint(0, cluster_num, count)

    clustering = AgglomerativeClustering(
        n_clusters=2).fit(np.array(feature_band_list))
    print(clustering.labels_)
    return clustering.labels_


def cv_imread(filePath):
    cv_img = cv2.imdecode(np.fromfile(filePath, dtype=np.uint8), -1)
    # imdecode读取的是rgb，如果后续需要opencv处理的话，需要转换成bgr，转换后图片颜色会变化
    # cv_img = cv2.cvtColor(cv_img,cv2.COLOR_RGB2BGR)
    return cv_img
